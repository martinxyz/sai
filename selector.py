"""
Simple Proof-Of-Concept Selector, using only the core saidb.

This can be replaced with a selector that queries some other DB built
by a fancy algorithm. (Deciding what articles are important, how to
generate keyword summaries, how to perform searches, etc.)
"""
import random, time
import saidb

class Selector(object):
    def __init__(self):
        self.chunk = None
        self.title = '<no article selected>'
        self.status = ''
        # TODO: keep track of reading context here / generate context-sensitive titles.
        # TODO: also maintain a list of related chunks (to read next) that the GUI can display.
        #       that list can change each time the user clicks on a keyword...
        self.saidb = saidb.SAIDB()

    def getKeywords(self):
        # could fetch autogenerated keywords here if empty
        return self.chunk.tags

    def updateText(self): 
        # could call some algorithm to generate content here, probably
        self.text = self.chunk.text

    def next(self):
        cur = self.saidb.con.cursor()
        cur.execute('SELECT c.id, e.report FROM chunks AS c, evaluator_scores AS e WHERE e.id = c.id ORDER BY (e.score - 1000*(SELECT COUNT(*) FROM shown AS s WHERE s.chunk = c.id)) DESC LIMIT 1')
        chunk_id, self.report = random.choice(list(cur))
        self.select(chunk_id)

    def nextRandom(self):
        cur = self.saidb.con.cursor()
        cur.execute('SELECT c.id, e.report FROM chunks AS c, evaluator_scores AS e WHERE e.id = c.id')
        chunk_id, self.report = random.choice(list(cur))
        self.select(chunk_id)

    def getLink(self, logging=False):
        url = self.chunk.url
        self.chunk.shown('linkfollowed')
        return url

    def select(self, chunk_id):
        self.chunk = self.saidb.getChunk(chunk_id)
        self.chunk.shown('fulltext')

    def markKeyword(self, word, change):
        # note: could use some algorithm here eg. to make all words singular, to recirect certain words, etc.
        word = word.lower()
        tags = self.chunk.tags[:]
        if word not in tags:
            tags.append(word)
            change -= 1
            if change < 0: return

        if change < 0 and tags[-1] == word:
            tags = tags[:-1]
        else:
            l = []
            for i, w in enumerate(tags):
                if w == word:
                    i += change * -1.001
                l.append((i, w))
            l.sort()
            tags = [w for i, w in l]

        if tags == self.chunk.tags: return
        self.chunk.setTags(tags)

    def rateWord(self, word, rating):
        # note: could recirect to other word here?
        self.chunk.setRating(word, rating)
